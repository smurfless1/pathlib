// Code generated by MockGen. DO NOT EDIT.
// Source: pathlib.go

// Package pathlib is a generated GoMock package.
package pathlib

import (
	gomock "github.com/golang/mock/gomock"
	os "os"
	reflect "reflect"
)

// MockPath is a mock of Path interface
type MockPath struct {
	ctrl     *gomock.Controller
	recorder *MockPathMockRecorder
}

// MockPathMockRecorder is the mock recorder for MockPath
type MockPathMockRecorder struct {
	mock *MockPath
}

// NewMockPath creates a new mock instance
func NewMockPath(ctrl *gomock.Controller) *MockPath {
	mock := &MockPath{ctrl: ctrl}
	mock.recorder = &MockPathMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPath) EXPECT() *MockPathMockRecorder {
	return m.recorder
}

// Parts mocks base method
func (m *MockPath) Parts() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Parts")
	ret0, _ := ret[0].([]string)
	return ret0
}

// Parts indicates an expected call of Parts
func (mr *MockPathMockRecorder) Parts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Parts", reflect.TypeOf((*MockPath)(nil).Parts))
}

// Absolute mocks base method
func (m *MockPath) Absolute() (Path, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Absolute")
	ret0, _ := ret[0].(Path)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Absolute indicates an expected call of Absolute
func (mr *MockPathMockRecorder) Absolute() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Absolute", reflect.TypeOf((*MockPath)(nil).Absolute))
}

// Cwd mocks base method
func (m *MockPath) Cwd() (Path, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cwd")
	ret0, _ := ret[0].(Path)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Cwd indicates an expected call of Cwd
func (mr *MockPathMockRecorder) Cwd() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cwd", reflect.TypeOf((*MockPath)(nil).Cwd))
}

// Parent mocks base method
func (m *MockPath) Parent() (Path, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Parent")
	ret0, _ := ret[0].(Path)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Parent indicates an expected call of Parent
func (mr *MockPathMockRecorder) Parent() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Parent", reflect.TypeOf((*MockPath)(nil).Parent))
}

// Touch mocks base method
func (m *MockPath) Touch() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Touch")
	ret0, _ := ret[0].(error)
	return ret0
}

// Touch indicates an expected call of Touch
func (mr *MockPathMockRecorder) Touch() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockPath)(nil).Touch))
}

// RmDir mocks base method
func (m *MockPath) RmDir() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RmDir")
	ret0, _ := ret[0].(error)
	return ret0
}

// RmDir indicates an expected call of RmDir
func (mr *MockPathMockRecorder) RmDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RmDir", reflect.TypeOf((*MockPath)(nil).RmDir))
}

// Unlink mocks base method
func (m *MockPath) Unlink() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlink")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlink indicates an expected call of Unlink
func (mr *MockPathMockRecorder) Unlink() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlink", reflect.TypeOf((*MockPath)(nil).Unlink))
}

// MkDir mocks base method
func (m *MockPath) MkDir(mode os.FileMode, parents bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDir", mode, parents)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDir indicates an expected call of MkDir
func (mr *MockPathMockRecorder) MkDir(mode, parents interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDir", reflect.TypeOf((*MockPath)(nil).MkDir), mode, parents)
}

// Open mocks base method
func (m *MockPath) Open() ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open")
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open
func (mr *MockPathMockRecorder) Open() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockPath)(nil).Open))
}

// Chmod mocks base method
func (m *MockPath) Chmod(mode os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod
func (mr *MockPathMockRecorder) Chmod(mode interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockPath)(nil).Chmod), mode)
}

// JoinPath mocks base method
func (m *MockPath) JoinPath(elem ...string) Path {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range elem {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JoinPath", varargs...)
	ret0, _ := ret[0].(Path)
	return ret0
}

// JoinPath indicates an expected call of JoinPath
func (mr *MockPathMockRecorder) JoinPath(elem ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JoinPath", reflect.TypeOf((*MockPath)(nil).JoinPath), elem...)
}

// Exists mocks base method
func (m *MockPath) Exists() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists
func (mr *MockPathMockRecorder) Exists() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockPath)(nil).Exists))
}

// IsAbsolute mocks base method
func (m *MockPath) IsAbsolute() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAbsolute")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsAbsolute indicates an expected call of IsAbsolute
func (mr *MockPathMockRecorder) IsAbsolute() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAbsolute", reflect.TypeOf((*MockPath)(nil).IsAbsolute))
}

// IsFile mocks base method
func (m *MockPath) IsFile() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFile")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsFile indicates an expected call of IsFile
func (mr *MockPathMockRecorder) IsFile() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFile", reflect.TypeOf((*MockPath)(nil).IsFile))
}

// IsDir mocks base method
func (m *MockPath) IsDir() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDir")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsDir indicates an expected call of IsDir
func (mr *MockPathMockRecorder) IsDir() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDir", reflect.TypeOf((*MockPath)(nil).IsDir))
}

// ExpandUser mocks base method
func (m *MockPath) ExpandUser() Path {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpandUser")
	ret0, _ := ret[0].(Path)
	return ret0
}

// ExpandUser indicates an expected call of ExpandUser
func (mr *MockPathMockRecorder) ExpandUser() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpandUser", reflect.TypeOf((*MockPath)(nil).ExpandUser))
}

// String mocks base method
func (m *MockPath) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String
func (mr *MockPathMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockPath)(nil).String))
}
